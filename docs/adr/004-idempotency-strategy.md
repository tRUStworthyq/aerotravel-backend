# 004. Стратегия обеспечения идемпотентности

* **Статус:** Принято
* **Владелец решения:** Максим Долгий dolgiy_m@list.ru
* **Дата:** 29.10.2025

## Контекст и постановка проблемы

### В проекте используются 2 типа коммуникации:

* Синхронная (REST API между Gateway и микросервисами)
* Асинхронная (Apache Kafka для межсервисного взаимодействия)

### В такой среде возможны ситуации:

* Повторные HTTP-запросы из-за сетевых сбоев или таймаутов
* Дублирование сообщений в Kafka (at-least-one)
* Конкурирующие запросы на изменение одного ресурса

### Это может привести к:

* Создание дублирующихся бронирований
* Многократное списание средств
* Несогласованность данных между сервисами

## Цели принятия решения

- Гарантия однократной обработки операций при повторных вызовах
- Обеспечение согласованности данных между сервисами
- Поддержка корректной работы Saga Pattern при бронировании
- Минимизация влияния сетевых сбоев на бизнес-процессы
- Обеспечение предсказуемого поведения системы при частичных отказах

## Рассмотренные варианты

### Вариант 1: Idempotency Key на уровне HTTP

* **Описание:** Клиент генерирует уникальный ключ идемпотентности для каждой операции и передает его в заголовке
* **Плюсы (+):**
    * Простота реализации для синхронных операций.
    * Понятный механизм для клиентов.
    * Хорошо работает для операций создания ресурсов.
* **Минусы (-):**
    * Не решает проблему дублирования в асинхронной коммуникации
    * Ограниченная применяемость для сложных бизнес процессов

### Вариант 2: Дедупликация на стороне consumer-ов Kafka

* **Описание:** Каждый сервис отслеживает ID обработанных сообщений в отдельном хранилище
* **Плюсы (+):**
    * Независимая реализация в каждом сервисе.
    * Простота внедрения для отдельных сервисов.
* **Минусы (-):**
    * Дублирование логики дедупликации
    * Риск рассинхронизации при масштабировании
    * Сложность управления TTL для идентификаторов

### Вариант 3: Единый механизм идемпотентности с использованием Redis

* **Описание:** Централизованное хранилище Redis для отслеживания выполненных операций с TTL
* **Плюсы (+):**
    * Единый подход для всех сервисов
    * Простота масштабирования
    * Поддержка как HTTP, так и Kafka сообщений
    * Автоматическая очистка устаревших данных
* **Минусы (-):**
    * Единая точка отказа
    * Дополнительная зависимость в инфраструктуре

## Выбранное решение

Был выбран **Вариант 3: Единый механизм идемпотентности с использованием Redis** с дополнениями:

### Для HTTP-запросов

* Gateway генерирует ```Idempotency-Key``` для мутирующих операций
* Ключ передается в заголовке всем downstream-сервисам
* Сервисы проверяют ключ в Redis перед выполнением операций

### Для Kafka сообщений

* Все сообщения содержат ```message_id``` и ```correlation_id```
* Consumer-ы отслеживают обработанные ```message_id``` в Redis
* TTL устанавливается на основе бизнес-логики

## Последствия

* **Положительные:**
    * Гарантированная однократная обработка операций
    * Улучшенная согласованность данных
    * Повышенная отказоустойчивость системы
    * Стандартизированный подход для всех сервисов
* **Отрицательные / Риски:**
    * Дополнительная сложность реализации
    * Единая точка отказа
    * Необходимость тщательного подбора TTL для разных операций
* **Что нужно сделать:**
    * [] Спроектировать схему ключей идемпотентности
    * [] Реализовать IdempotencyService в common-модуле
    * [] Интегрировать проверку идемпотентности в Gateway
    * [] Добавить idempotency-key в DTO для мутирующих операций
    * [] Настроить Redis кластер
    * [] Разработать тесты для сценариев повторных запросов

## Дополнительные материалы

* [Обработка дубликатов в Apache Kafka](https://www.confluent.io/blog/exactly-once-semantics-are-possible-heres-how-apache-kafka-does-it/)
* [Идемпотентность в REST API](https://docs.stripe.com/api/idempotent_requests)
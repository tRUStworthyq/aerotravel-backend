# 002. Выбор способа коммуникации между микросервисами

* **Статус:** Принято
* **Владелец решения:** Максим Долгий dolgiy_m@list.ru
* **Дата:** 09.10.2025

## Контекст и постановка проблемы

Для проекта была выбрана микросервисная архитектура [ADR-001](001-microservices-architecture.md). Критически важным становится выбор способа взаимодействия между сервисами.
Необходим механизм, который обеспечит слабую связанность, высокую производительность и отказоустойчивость.

## Цели принятия решения

- Обеспечение горизонтального масштабирования системы под нагрузку до 100k+ пользователей.
- Обработка до 10k+ запросов в секунду с минимальной задержкой.
- Поддержка линейного масштабирования пропускной способности при добавлении новых сервисов.
- Повышение отказоустойчивости системы.

## Рассмотренные варианты

### Вариант 1: REST API

* **Описание:** Использование HTTP-запросов. Сервисы напрямую вызывают API друг друга.
* **Плюсы (+):**
  * Простота понимания и отладки.
  * Богатый инструментарий.
  * Хорошо подходит для сценариев, где немедленный ответ критически важен.
* **Минусы (-):**
  * Создает сильную связность между сервисами.
  * Нет отказоустойчивости: если сервис-B недоступен, то сервис-A или падает или вынужден обрабатывать ошибки.
  * Накладные расходы HTTP: заголовки, текстовые форматы.
  * Плохо масштабируется при каскадных вызовах.
  * Синхронная модель.

### Вариант 2: gRPC

* **Описание:** Высокопроизводительный RPC фреймворк, использующий HTTP/2 и формат Protocol Buffers.
* **Плюсы (+):**
  * Высокая производительность.
  * Контракты через .proto файлы
  * Автогенерация кода для клиентов и серверов.
* **Минусы (-):**
  * Создает сильную связность между сервисами. 
  * Сложность отладки.
  * Синхронная модель.

### Вариант 3: Apache Kafka

* **Описание:** Брокер сообщений (Apache Kafka). Сервисы общаются, публикуя и подписываясь на потоки событий (топики).
* **Плюсы (+):**
  * Слабая связанность.
  * Высокая отказоустойчивость.
  * Высокая пропускная способность.
  * Простое горизонтальное масштабирование.
  * Поддержка множества consumer-ов.
* **Минусы (-):**
  * Сложность операционной эксплуатации (развертывание, мониторинг и настройка кластера).
  * Не подходит для ситуаций, где требуется немедленный синхронный ответ.

## Выбранное решение

Был выбран **Вариант 3: Apache Kafka**, так как он наилучшим образом соответствует целям обеспечения слабой связанности,
высокой производительности и отказоустойчивости, однако в сценариях, требующих немедленного ответа, может потребоваться
другой подход, например REST. 

## Последствия

* **Положительные:**
  * Система станет устойчивой к простоям отдельных сервисов.
  * Упрощение обработки пиковых нагрузок.
  * Единый источник истины для потоков данных в системе.
* **Отрицательные / Риски:**
  * Необходимость отладки потоков событий.
  * Появится новая критически важная структурная компонента требующая эксплуатации и мониторинга.
* **Что нужно сделать:**
  * [&check;] Развернуть и сконфигурировать Apache Kafka.
  * [] Разработать и задокументировать стандарты и конвенции для именования топиков и форматов сообщений в internal-interface.
  * [] Внедрить мониторинг для Kafka и ключевых потоков событий.

## Дополнительные материалы

* [ADR-001: Выбор архитектуры: микросервисы против монолита](https://microservices.io/)
* [Документация Apache Kafka](https://kafka.apache.org/documentation/)